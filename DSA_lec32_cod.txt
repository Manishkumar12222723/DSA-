/****************************
Manish Kumar
****************************/



Single File Programming Question
Problem Statement



You are a skilled software engineer working for a renowned gaming company that is developing an exciting new game called "The Treasure Hunt".



In this game, players embark on an adventurous journey to find hidden treasures in a mysterious forest.



To make the game more intriguing, the developers decided to introduce a unique way of organizing the treasures using a min-heap data structure. Each treasure is represented by an integer value, and they want you to create a min-heap from the given set of treasures.



Write a program to create a min-heap from the given array of integers.

Input format :
The first line of the input consists of an integer n, the total number of treasures. 

The second line of the input consists of n space-separated elements.

Output format :
The output prints the given array of treasure values into a min-heap data structure. The values printed are space-separated.

Sample test cases :
Input 1 :
5
2 4 1 5 9
Output 1 :
1 4 2 5 9 
Input 2 :
7
8 7 6 4 5 1 2
Output 2 :
1 4 2 7 5 6 8 



// You are using GCC
#include <iostream>
using namespace std;

void min_heap(int *a, int m, int n){
       int j, t;
          t= a[m];
             j = 2 * m;
                while (j <= n) {
                          if (j < n && a[j+1] < a[j])
                                   j = j + 1;
                                         if (t < a[j])
                                                  break;
                                                        else if (t >= a[j]) {
                                                                     a[j/2] = a[j];
                                                                              j = 2 * j;
                                                        }
                }
                   a[j/2] = t;
                      return;
}
void build_minheap(int *a, int n) {
       int k;
          for(k = n/2; k >= 1; k--) {
                    min_heap(a,k,n);
          }
}
int main() {
       int n, i;
          cin>>n;
            
               int a[n];
                  for (i = 1; i <= n; i++) {
                           cin>>a[i];
                  }
                     build_minheap(a, n);
                        for (i = 1; i <= n; i++) {
                                  cout<<a[i]<<" ";
                        }
}



///////////////////////////////////
SACHIN
//////////////////////////////////




Single File Programming Question
Problem Statement



You are a talented computer scientist specializing in data structures and algorithms. 



One day, you receive a challenging task from a group of archaeologists who are studying ancient artifacts. They have discovered a mysterious array that seems to represent a min heap tree. However, they find it difficult to retrieve the largest element efficiently from the min heap.



Your task is to help them convert the given min heap array into a max heap representation so that they can easily retrieve the largest element from the tree.



Note: This kind of question will be helpful in clearing Accenture recruitment.

Input format :
The first line of input consists of an integer n, the number of elements in the min heap tree. 

The second line of input consists of n space-separated elements, forming the min heap sequence.

Output format :
The output prints the max heap array formed after the conversion.

Sample test cases :
Input 1 :
10
3 5 9 6 8 20 10 12 18 9
Output 1 :
20 18 10 12 9 9 3 5 6 8 
Input 2 :
5
5 6 8 11 15
Output 2 :
15 11 8 5 6 


// You are using GCC
#include <iostream>
using namespace std;

// to heapify a subtree with root at given index
void MaxHeapify(int arr[], int i, int N)
{
        int l = 2 * i + 1;
            int r = 2 * i + 2;
                int largest = i;
                
                    if (l < N && arr[l] > arr[i])
                            largest = l;
                                if (r < N && arr[r] > arr[largest])
                                        largest = r;
                                            if (largest != i) {
                                                        swap(arr[i], arr[largest]);
                                                                MaxHeapify(arr, largest, N);
                                            }
}

// This function basically builds max heap
void convertMaxHeap(int arr[], int N)
{
        // Start from bottommost and rightmost internal node and heapify all internal nodes in bottom up way
            for (int i = (N - 2) / 2; i >= 0; --i)
                    MaxHeapify(arr, i, N);
}


void printArray(int* arr, int size)
{
        for (int i = 0; i < size; ++i)
                cout << arr[i] << " ";
                    cout<<endl;
}

int main()
{
        int arrayCount;
            cin>>arrayCount;
                int arr[arrayCount];
                    for (int i=0;i<arrayCount;i++){
                                cin>>arr[i];
                    }
                    
                        convertMaxHeap(arr, arrayCount);
                        
                            printArray(arr, arrayCount);
                            
                                return 0;
}




Single File Programming Question
Problem Statement



Write a program to implement insertion in the k-ary min heap.



Example



Input:

12 3

80 90 40 50 60 70 30 10 20 100 120 110



Output:

Heap = 10 40 20 50 90 70 60 80 30 100 120 110 



Explanation:

k=3

Apply the min-heap property to store the value in the 3-ary min heap and print the value using the level order method.

Input format :
The first line of input consists of the size n and k value, separated by space.

The second line of input consists of n elements, separated by space.

Output format :
The output prints the k-ary min-heap using the level order, separated by space.



Refer to the sample output for formatting specifications.

Sample test cases :
Input 1 :
12 3
80 90 40 50 60 70 30 10 20 100 120 110
Output 1 :
Heap = 10 40 20 50 90 70 60 80 30 100 120 110 


// You are using GCC
#include <iostream>
#include <algorithm>

using namespace std;

/** Class D-ary Heap **/
class DaryHeap
{
    private:
        /** The number of children each node has **/
            int d;
                int heapSize;
                    int capacity;
                        int *heap;
                        
                            /** Function to  get index parent of i **/
                                int parent(int i)
                                    {
                                                return (i - 1) / d;
                                    }
                                    
                                        /** Function to get index of k th child of i **/
                                            int kthChild(int i, int k)
                                                {
                                                            return d * i + k;
                                                }
                                                
                                                    /** Function heapifyUp  **/
                                                        void heapifyUp(int childInd)
                                                            {
                                                                        int tmp = heap[childInd];
                                                                                while (childInd > 0 && tmp < heap[parent(childInd)])
                                                                                        {
                                                                                                        heap[childInd] = heap[parent(childInd)];
                                                                                                                    childInd = parent(childInd);
                                                                                        }
                                                                                                heap[childInd] = tmp;
                                                            }
                                                            
                                                                /** Function heapifyDown **/
                                                                    void heapifyDown(int ind)
                                                                        {
                                                                                    int child;
                                                                                            int tmp = heap[ind];
                                                                                                    while (kthChild(ind, 1) < heapSize)
                                                                                                            {
                                                                                                                            child = minChild(ind);
                                                                                                                                        if (heap[child] < tmp)
                                                                                                                                                        heap[ind] = heap[child];
                                                                                                                                                                    else
                                                                                                                                                                                    break;
                                                                                                                                                                                                ind = child;
                                                                                                            }
                                                                                                                    heap[ind] = tmp;
                                                                        }
                                                                        
                                                                            /** Function to get smallest child **/
                                                                                int minChild(int ind)
                                                                                    {
                                                                                                int bestChild = kthChild(ind, 1);
                                                                                                        int k = 2;
                                                                                                                int pos = kthChild(ind, k);
                                                                                                                        while ((k <= d) && (pos < heapSize))
                                                                                                                                {
                                                                                                                                                if (heap[pos] < heap[bestChild])
                                                                                                                                                                bestChild = pos;
                                                                                                                                                                            pos = kthChild(ind, k++);
                                                                                                                                }
                                                                                                                                        return bestChild;
                                                                                    }
                                                                                    
                                                                                    public:
                                                                                        /** Constructor **/
                                                                                            DaryHeap(int capacity, int numChild)
                                                                                                {
                                                                                                            heapSize = 0;
                                                                                                                    d = numChild;
                                                                                                                            this->capacity = capacity;
                                                                                                                                    heap = new int[capacity];
                                                                                                                                            fill(heap, heap + capacity, -1);
                                                                                                }
                                                                                                
                                                                                                    /** Function to check if heap is empty **/
                                                                                                        bool isEmpty()
                                                                                                            {
                                                                                                                        return heapSize == 0;
                                                                                                            }
                                                                                                            
                                                                                                                /** Check if heap is full **/
                                                                                                                    bool isFull()
                                                                                                                        {
                                                                                                                                    return heapSize == capacity;
                                                                                                                        }
                                                                                                                        
                                                                                                                            /** Function to clear heap **/
                                                                                                                                void clear()
                                                                                                                                    {
                                                                                                                                                heapSize = 0;
                                                                                                                                    }
                                                                                                                                    
                                                                                                                                        /** Function to insert element **/
                                                                                                                                            void insert(int x)
                                                                                                                                                {
                                                                                                                                                            if (isFull())
                                                                                                                                                                        throw runtime_error("Overflow Exception");
                                                                                                                                                                                /** Percolate up **/
                                                                                                                                                                                        heap[heapSize++] = x;
                                                                                                                                                                                                heapifyUp(heapSize - 1);
                                                                                                                                                }
                                                                                                                                                
                                                                                                                                                    /** Function to find least element **/
                                                                                                                                                        int findMin()
                                                                                                                                                            {
                                                                                                                                                                        if (isEmpty())
                                                                                                                                                                                    throw runtime_error("Underflow Exception");
                                                                                                                                                                                            return heap[0];
                                                                                                                                                            }
                                                                                                                                                            
                                                                                                                                                                /** Function to delete element at an index **/
                                                                                                                                                                    int deleteElem(int ind)
                                                                                                                                                                        {
                                                                                                                                                                                    if (isEmpty())
                                                                                                                                                                                                throw runtime_error("Underflow Exception");
                                                                                                                                                                                                        int keyItem = heap[ind];
                                                                                                                                                                                                                heap[ind] = heap[heapSize - 1];
                                                                                                                                                                                                                        heapSize--;
                                                                                                                                                                                                                                heapifyDown(ind);
                                                                                                                                                                                                                                        return keyItem;
                                                                                                                                                                        }
                                                                                                                                                                        
                                                                                                                                                                            /** Function to print heap **/
                                                                                                                                                                                void printHeap()
                                                                                                                                                                                    {
                                                                                                                                                                                                cout << "Heap = ";
                                                                                                                                                                                                        for (int i = 0; i < heapSize; i++)
                                                                                                                                                                                                                    cout << heap[i] << " ";
                                                                                                                                                                                                                            cout << endl;
                                                                                                                                                                                    }
                                                                                                                                                                                    
                                                                                                                                                                                        /** Destructor **/
                                                                                                                                                                                            ~DaryHeap()
                                                                                                                                                                                                {
                                                                                                                                                                                                            delete[] heap;
                                                                                                                                                                                                }
};

/** Class DaryHeapTest **/
int main()
{
        int i, size, d;
            cin >> size >> d;
                /** Make object of DaryHeapHeap **/
                    DaryHeap dh(size, d);
                    
                        for (i = 0; i < size; i++)
                            {
                                        int num;
                                                cin >> num;
                                                        dh.insert(num);
                            }
                            
                                dh.printHeap();
                                
                                    return 0;
}

  


Problem Statement



Welcome to the mystical land of Elaria, a realm filled with magic, ancient artifacts, and enigmatic creatures. You are an aspiring sorcerer on a quest to find the legendary Enchanted Amulet—an artifact of immeasurable power said to grant its possessor extraordinary abilities.



To aid you in your quest, the wise council of wizards has devised a unique way to guide you through the treacherous journey. They have enchanted a special set of gemstones, each possessing a mystical power that will lead you closer to the Enchanted Amulet.



The council has placed these enchanted gemstones in an array, and your task is to convert the array into a min heap, which will help you identify the gemstone with the kth most potent magic.



Given an array of elements and an element k, find the kth element after converting the array into a min-heap.



Note: This question was asked in Cisco recruitment.

Input format :
The first line of input consists of the number of elements n in the array.

The second line of input consists of n array elements.

The third line of input consists of the value of k.

Output format :
The first line of output prints the min-heap.

The second line of output prints the kth element in the min-heap.

If k>n, print "Invalid entry".



Refer to the sample output for formatting specifications.

Code constraints :
n>0

k<=n

Sample test cases :
Input 1 :
5
2 4 1 5 9
4
Output 1 :
Min heap is 1 4 2 5 9 
The kth element in min-heap is 5.
Input 2 :
8
1 4 7 8 5 2 3 6
10
Output 2 :
Invalid entry



// You are using GCC
#include <iostream>
using namespace std;

void min_heap(int *a, int m, int n){
       int j, t;
          t= a[m];
             j = 2 * m;
                while (j <= n) {
                          if (j < n && a[j+1] < a[j])
                                   j = j + 1;
                                         if (t < a[j])
                                                  break;
                                                        else if (t >= a[j]) {
                                                                     a[j/2] = a[j];
                                                                              j = 2 * j;
                                                        }
                }
                   a[j/2] = t;
                      return;
}
void build_minheap(int *a, int n) {
       int k;
          for(k = n/2; k >= 1; k--) {
                    min_heap(a,k,n);
          }
}
int main() {
       int n, i;
          cin>>n;
            
               int a[n];
                  for (i = 1; i <= n; i++) {
                           cin>>a[i];
                  }
                     int elementToFind;
                        cin>>elementToFind;
                        
                           if(elementToFind<1 || elementToFind > n){
                                     cout<<"Invalid entry"<<endl;
                                           return 0;
                           }
                              build_minheap(a, n);
                                 cout<<"Min heap is ";
                                    for (i = 1; i <= n; i++) {
                                             cout<<a[i]<<" ";
                                    }
                                       cout<<endl;
                                          
                                             cout<<"The kth element in min-heap is "<<a[elementToFind] <<".";
                                                cout<<endl;
}





Single File Programming Question
Problem Statement



You are asked to write a network simulator for your university and you are given the time taken for a packet to pass from a given router to all the connected nodes. But this data is stored in the heap as a min-heap tree, which makes it difficult to retrieve the details about the node that takes the longest to reach. 



Write a program to take in the min-heap data as input and convert it to a max-heap representation which would help in retrieving the largest element from the tree.



Note: This kind of question will be helpful in clearing Accenture recruitment.

Input format :
The first line of input consists of an integer n, the number of elements in the min heap tree. 

The second line of input consists of n space-separated elements, forming the min heap sequence.

Output format :
The output prints the max heap array formed after the conversion followed by the data which is the largest in the tree.



Refer to the sample output for formatting specifications.

Sample test cases :
Input 1 :
7
3 13 7 16 21 12 9
Output 1 :
21 16 12 3 13 7 9 
The largest element is 21
Input 2 :
10
2 5 13 20 17 25 19 20 23 20
Output 2 :
25 23 19 20 20 13 2 5 20 17 
The largest element is 25


#include <iostream>
using namespace std;

// to heapify a subtree with root at given index
void MaxHeapify(int arr[], int i, int N)
{
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    int largest = i;

    if (l < N && arr[l] > arr[i])
        largest = l;
    if (r < N && arr[r] > arr[largest])
        largest = r;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        MaxHeapify(arr, largest, N);
    }
}

// This function basically builds max heap
void convertMaxHeap(int arr[], int N)
{
    // Start from bottommost and rightmost internal node and heapify all internal nodes in bottom up way
    for (int i = (N - 2) / 2; i >= 0; --i)
        MaxHeapify(arr, i, N);
}


void printArray(int* arr, int size)
{
    for (int i = 0; i < size; ++i)
        cout << arr[i] << " ";
    cout<<endl;
}

int main()
{
    int arrayCount;
    cin>>arrayCount;
    int arr[arrayCount];
    for (int i=0;i<arrayCount;i++){
        cin>>arr[i];
    }

    convertMaxHeap(arr, arrayCount);

    printArray(arr, arrayCount);
    cout<<"The largest element is "<<arr[0]<<endl;

    return 0;
}


Single File Programming Question
Problem Statement



The heap data structure is very useful if you want to create a video game as it is easy to store the future events which might occur at a time in the heap and retrieve them quickly. 



Write a program that would take in the event times of the video game and create a min-heap. The event times are represented as integers for now. Your output shall be the min-heap of the given input.

Input format :
The first line of input consists of an integer n, the total number of events. 

The second line of input consists of n space-separated elements.

Output format :
The output prints the given array of events into a min-heap data structure.

Sample test cases :
Input 1 :
5
2 4 1 5 9
Output 1 :
1 4 2 5 9 
Input 2 :
7
8 7 6 4 5 1 2
Output 2 :
1 4 2 7 5 6 8 


#include <iostream>
using namespace std;

void min_heap(int *a, int m, int n){
   int j, t;
   t= a[m];
   j = 2 * m;
   while (j <= n) {
      if (j < n && a[j+1] < a[j])
         j = j + 1;
      if (t < a[j])
         break;
      else if (t >= a[j]) {
         a[j/2] = a[j];
         j = 2 * j;
      }
   }
   a[j/2] = t;
   return;
}
void build_minheap(int *a, int n) {
   int k;
   for(k = n/2; k >= 1; k--) {
      min_heap(a,k,n);
   }
}
int main() {
   int n, i;
   cin>>n;
  
   int a[n];
   for (i = 1; i <= n; i++) {
     cin>>a[i];
   }
   build_minheap(a, n);
   for (i = 1; i <= n; i++) {
      cout<<a[i]<<" ";
   }
}



Problem Statement



While trying to plan a trip to a new city as part of your vacation, you decide to create a map of the places that you would like to visit. The time taken to travel between two places is recorded as integers. You and your friend decide to automate the problem in order to find out which two places need more time to travel between them. 



You decide on a Heap data structure but your friend implemented the same using a min-heap tree, which makes it difficult to retrieve the details you actually wanted. 



Write a program to take in the min-heap data as input and convert it to a max heap representation which would help in retrieving the time that is the largest among the given set.



Note: This kind of question will be helpful in clearing Accenture recruitment.

Input format :
The first line of input consists of an integer n, the number of elements in the min heap tree. 

The second line of input consists of n space-separated elements, forming the min heap sequence.

Output format :
The output prints the max heap array formed after the conversion.

Sample test cases :
Input 1 :
6
10 20 50 30 80 60 70
Output 1 :
80 30 60 10 20 50 
Input 2 :
10
4 6 9 7 8 20 10 12 19 10
Output 2 :
20 19 10 12 10 9 4 6 7 8 



#include <iostream>
using namespace std;

// to heapify a subtree with root at given index
void MaxHeapify(int arr[], int i, int N)
{
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    int largest = i;

    if (l < N && arr[l] > arr[i])
        largest = l;
    if (r < N && arr[r] > arr[largest])
        largest = r;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        MaxHeapify(arr, largest, N);
    }
}

// This function basically builds max heap
void convertMaxHeap(int arr[], int N)
{
    // Start from bottommost and rightmost internal node and heapify all internal nodes in bottom up way
    for (int i = (N - 2) / 2; i >= 0; --i)
        MaxHeapify(arr, i, N);
}


void printArray(int* arr, int size)
{
    for (int i = 0; i < size; ++i)
        cout << arr[i] << " ";
    cout<<endl;
}

int main()
{
    int arrayCount;
    cin>>arrayCount;
    int arr[arrayCount];
    for (int i=0;i<arrayCount;i++){
        cin>>arr[i];
    }

    convertMaxHeap(arr, arrayCount);

    printArray(arr, arrayCount);

    return 0;
}




T20 matches award the players for either scoring a lot of runs or for taking a lot of wickets. You love T20 cricket matches and want to keep track of the bowler's performance to see who gets the purple cap this year. 



This application would be handy if the data was stored in the heap, especially the max heap which will help you retrieve the highest wicket-taker easily.



Write a program that takes in integers representing the wickets taken by different bowlers and generates a max heap representation of the same.



Note: This kind of question will be helpful in clearing TCS recruitment.

Input format :
The first line of input consists of an integer n, the total number of wickets taken. 

The second line of input consists of n space-separated elements.

Output format :
The output prints the given array of wickets into a max-heap data structure.

Sample test cases :
Input 1 :
5
2 4 1 5 9
Output 1 :
9 5 1 2 4 
Input 2 :
7
8 7 6 4 5 1 2
Output 2 :
8 7 6 4 5 1 2 


#include <iostream>
using namespace std;

void max_heap(int *a, int m, int n){
   int j, t;
   t= a[m];
   j = 2 * m;
   while (j <= n) {
      if (j < n && a[j+1] > a[j])
         j = j + 1;
      if (t > a[j])
         break;
      else if (t <= a[j]) {
         a[j/2] = a[j];
         j = 2 * j;
      }
   }
   a[j/2] = t;
   return;
}
void build_maxheap(int *a, int n) {
   int k;
   for(k = n/2; k >= 1; k--) {
      max_heap(a,k,n);
   }
}
int main() {
   int n, i;
   cin>>n;
  
   int a[n];
   for (i = 1; i <= n; i++) {
     cin>>a[i];
   }
   build_maxheap(a, n);
   for (i = 1; i <= n; i++) {
      cout<<a[i]<<" ";
   }
}


Problem Statement:



In your company instead of using resource scheduling software from a famous vendor's project management software, the management decides to create their own system to allocate resources. Each task that gets allocated to a resource is assigned a priority and similarly, each resource is also assigned a weightage to indicate their importance and their contribution level. While trying to assign a task to a resource, they would need to match the priority and the importance to ensure it is a perfect fit. 



As the first step, your team has been asked to create a program to accept a set of integers representing the priorities of tasks and arrange them in such a way it is easy to retrieve the task with the maximum priority. The same program can be reused for resources with the highest weights too.



Write a program that creates a max heap of the given set of integers and retrieves the maximum value from the same.

Input format :
The first line of your input consists of an integer n which represents the total number of inputs.

The second line consists of the n integers, separated by space.

Output format :
The first line of output prints the max heap elements.

The second line of output prints the maximum value from the heap.



Refer to the sample output for formatting specifications.

Code constraints :
n > 0

Sample test cases :
Input 1 :
5
2 4 1 5 9
Output 1 :
Max heap
9 5 1 2 4 
The maximum value is 9

#include <iostream>
using namespace std;

void max_heap(int *a, int m, int n){
   int j, t;
   t= a[m];
   j = 2 * m;
   while (j <= n) {
      if (j < n && a[j+1] > a[j])
         j = j + 1;
      if (t > a[j])
         break;
      else if (t <= a[j]) {
         a[j/2] = a[j];
         j = 2 * j;
      }
   }
   a[j/2] = t;
   return;
}
void build_maxheap(int *a, int n) {
   int k;
   for(k = n/2; k >= 1; k--) {
      max_heap(a,k,n);
   }
}
int main() {
   int n, i;
   cin>>n;
  
   int a[n];
   for (i = 1; i <= n; i++) {
     cin>>a[i];
   }
   build_maxheap(a, n);
   cout<<"Max heap"<<endl;
   for (i = 1; i <= n; i++) {
      cout<<a[i]<<" ";
   }
   cout<<endl;
   cout<<"The maximum value is "<<a[1]<<endl;
}




One of the popular algorithms which is very frequently used in software engineering is Dijkstra’s algorithm. 



The canonical serial algorithm for solving the Single Source Shortest Path problem on graphs with non-negative edge weights is Dijkstra’s algorithm stores the vertices of a graph in a minimum priority queue Q keyed on the best-known distance to each vertex. 



A common implementation for this priority queue is a k-ary heap. 



Your task is to write a k-ary heap program that can be used to complete Dijkstra’s algorithm and another such algorithm that might use such a heap structure.  

Input format :
The first line of input consists of the size n and k value, separated by space.

The second line of input consists of n elements, separated by space.

Output format :
The output prints the k-ary heap, separated by space.

Sample test cases :
Input 1 :
15 3
9 8 3 2 1 4 5 6 7 15 12 13 14 11 10
Output 1 :
15 11 9 14 10 4 5 6 7 3 12 13 2 1 8 


#include<iostream>
using namespace std;

void restoreDown(int arr[], int len, int index,
										int k)
{
	// child array to store indexes of all
	// the children of given node
	int child[k+1];

	while (1)
	{
		// child[i]=-1 if the node is a leaf
		// children (no children)
		for (int i=1; i<=k; i++)
			child[i] = ((k*index + i) < len) ?
					(k*index + i) : -1;

		// max_child stores the maximum child and
		// max_child_index holds its index
		int max_child = -1, max_child_index ;

		// loop to find the maximum of all
		// the children of a given node
		for (int i=1; i<=k; i++)
		{
			if (child[i] != -1 &&
				arr[child[i]] > max_child)
			{
				max_child_index = child[i];
				max_child = arr[child[i]];
			}
		}

		// leaf node
		if (max_child == -1)
			break;

		// swap only if the key of max_child_index
		// is greater than the key of node
		if (arr[index] < arr[max_child_index])
			swap(arr[index], arr[max_child_index]);

		index = max_child_index;
	}
}

void restoreUp(int arr[], int index, int k)
{
	int parent = (index-1)/k;

	// Loop should only run till root node in case the
	// element inserted is the maximum restore up will
	// send it to the root node
	while (parent>=0)
	{
		if (arr[index] > arr[parent])
		{
			swap(arr[index], arr[parent]);
			index = parent;
			parent = (index -1)/k;
		}

		// node has been restored at the correct position
		else
			break;
	}
}

// Function to build a heap of arr[0..n-1] and value of k.
void buildHeap(int arr[], int n, int k)
{
	// Heapify all internal nodes starting from last
	// non-leaf node all the way upto the root node
	// and calling restore down on each
	for (int i= (n-1)/k; i>=0; i--)
		restoreDown(arr, n, i, k);
}

// Function to insert a value in a heap. Parameters are
// the array, size of heap, value k and the element to
// be inserted
void insert(int arr[], int* n, int k, int elem)
{
	// Put the new element in the last position
	arr[*n] = elem;

	// Increase heap size by 1
	*n = *n+1;

	// Call restoreUp on the last index
	restoreUp(arr, *n-1, k);
}

// Function that returns the key of root node of
// the heap and then restores the heap property
// of the remaining nodes
int extractMax(int arr[], int* n, int k)
{
	// Stores the key of root node to be returned
	int max = arr[0];

	// Copy the last node's key to the root node
	arr[0] = arr[*n-1];

	// Decrease heap size by 1
	*n = *n-1;

	// Call restoreDown on the root node to restore
	// it to the correct position in the heap
	restoreDown(arr, *n, 0, k);

	return max;
}

// Driver program
int main()
{
     int n;
     cin>>n;
     int k;
	cin>>k;
	int arr[n];
	for(int i=0;i<n;i++){
	    cin>>arr[i];
	}


	buildHeap(arr, n, k);

	for (int i=0; i<n; i++)
	    cout<<arr[i]<<" ";
	return 0;
}





Jagan is tasked to create a task scheduler for his system programming project. The tasks have a running time associated with it. When there is an issue with the execution of the tasks he needs to analyse and the one with the longest running time needs to be forced to exit. 



Help Jagan by automating the task by taking in the times of various tasks and arranging them in max heap format which will help him identify the longest-running task easily.



Note: This kind of question will be helpful in clearing TCS recruitment.

Input format :
The first line of your input consists of an integer n which represents the total number of inputs.

The second line consists of the n integers, separated by space.

Output format :
The output shows the input data in max heap order.

Code constraints :
n > 0

Sample test cases :
Input 1 :
5
2 4 1 5 9
Output 1 :
9 5 1 2 4 


#include <iostream>
using namespace std;

void max_heap(int *a, int m, int n){
   int j, t;
   t= a[m];
   j = 2 * m;
   while (j <= n) {
      if (j < n && a[j+1] > a[j])
         j = j + 1;
      if (t > a[j])
         break;
      else if (t <= a[j]) {
         a[j/2] = a[j];
         j = 2 * j;
      }
   }
   a[j/2] = t;
   return;
}
void build_maxheap(int *a, int n) {
   int k;
   for(k = n/2; k >= 1; k--) {
      max_heap(a,k,n);
   }
}
int main() {
   int n, i;
   cin>>n;
  
   int a[n];
   for (i = 1; i <= n; i++) {
     cin>>a[i];
   }
   build_maxheap(a, n);
   for (i = 1; i <= n; i++) {
      cout<<a[i]<<" ";
   }
}


Single File Programming Question
Problem Statement



As a cyber security analyst, I have to go through a lot of log files to analyze and evaluate the threats and risks posed to my company. The number of files that a system or an application generates is huge. Searching through the filenames and looking for a specific file is a tedious process.



I would you to create a program for me that takes in the list of filenames and provides me with the kth file from the list. Your output should display the list of file names in min heap order and specify the kth element from the min heap.

Input format :
The first line of input consists of the number of elements n.

The second line of input consists of n array elements.

The third line of input consists of the value of k.

Output format :
The output prints the min-heap.

The last output prints the kth element in the min-heap.

If k>n, print "Invalid entry".



Refer to the sample output for formatting specifications.

Code constraints :
n>0

k<=n

Sample test cases :
Input 1 :
10
VehiculaCondimentumCurabitur.avi
AtVelitVivamus.doc
NuncRhoncus.tiff
ProinRisusPraesent.ppt
LoremIntegerTincidunt.doc
IdNislVenenatis.xls
MusEtiamVel.mp3
Sapien.avi
Sagittis.ppt
Pretium.avi
5
Output 1 :
1: AtVelitVivamus.doc
2: LoremIntegerTincidunt.doc
3: IdNislVenenatis.xls
4: ProinRisusPraesent.ppt
5: Pretium.avi
6: NuncRhoncus.tiff
7: MusEtiamVel.mp3
8: Sapien.avi
9: Sagittis.ppt
10: VehiculaCondimentumCurabitur.avi
kth element in min-heap: Pretium.avi
Input 2 :
10
VehiculaCondimentumCurabitur.avi
AtVelitVivamus.doc
NuncRhoncus.tiff
ProinRisusPraesent.ppt
LoremIntegerTincidunt.doc
IdNislVenenatis.xls
MusEtiamVel.mp3
Sapien.avi
Sagittis.ppt
Pretium.avi
11
Output 2 :
Invalid entry


#include <iostream>
using namespace std;

void min_heap(string a[], int m, int n){
   int j;
   string t;
   t= a[m];
   j = 2 * m;
   while (j <= n) {
      if (j < n && a[j+1] < a[j])
         j = j + 1;
      if (t < a[j])
         break;
      else if (t >= a[j]) {
         a[j/2] = a[j];
         j = 2 * j;
      }
   }
   a[j/2] = t;
   return;
}
void build_minheap(string a[], int n) {
   int k;
   for(k = n/2; k >= 1; k--) {
      min_heap(a,k,n);
   }
}
int main() {
   int n, i;
   cin>>n;
  
   string a[n+1];
   for (i = 1; i <= n; i++) {
     cin>>a[i];
   }
   int elementToFind;
   cin>>elementToFind;

   if(elementToFind<1 || elementToFind > n){
      cout<<"Invalid entry"<<endl;
      return 0;
   }
   build_minheap(a, n);
   for (i = 1; i <= n; i++) {
     cout<<i<<": "<<a[i]<<endl;
   }
   cout<<"kth element in min-heap: "<<a[elementToFind] ;
}



